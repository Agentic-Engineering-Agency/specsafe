# SPEC-20260211-001: Interactive Coding Tools Integration

**Status:** Ready for Implementation  
**Priority:** P0  
**Target Version:** v0.2.0

## Overview

Enhance `specsafe init` with interactive tooling detection and setup, plus a new `specsafe rules` command for managing AI coding assistant integrations. This brings SpecSafe to parity with OpenSpec/SpecKit's approach while maintaining our spec-driven workflow.

## Goals

1. **Zero-friction onboarding** â€” Detect existing tools and auto-configure
2. **Multi-tool support** â€” Cursor, Continue.dev, Aider, Zed, and more
3. **Consistent experience** â€” Same spec-driven workflow across all tools
4. **Easy updates** â€” `specsafe rules update` pulls latest configurations

## User Flow

### 1. Interactive Init (`specsafe init`)

```bash
$ specsafe init my-project

? Project name: my-project
? Which AI coding assistants do you use? (detected from existing configs)
  [âœ“] Cursor IDE (.cursorrules found)
  [ ] Continue.dev
  [âœ“] Aider CLI (.aider.conf.yml found)
  [ ] Zed Editor

? Select testing framework:
  > Vitest (recommended)
    Jest
    Playwright (E2E)

? Enable git hooks for spec validation? Yes

âœ“ Created specsafe.config.json
âœ“ Generated .cursorrules for Cursor IDE
âœ“ Generated .aider.conf.yml for Aider CLI
âœ“ Set up Vitest configuration
âœ“ Installed git hooks via simple-git-hooks
âœ“ Created initial PROJECT_STATE.md

Run 'specsafe new feature-name' to create your first spec.
```

### 2. Adding Rules Later (`specsafe rules`)

```bash
# Add rules for a specific tool
$ specsafe rules add continue
âœ“ Downloaded Continue.dev rules from @specsafe/rules
âœ“ Created .continue/config.json
âœ“ Created .continue/rules.md

# List available and installed rules
$ specsafe rules list
Available Rules:
  cursor       [installed] Cursor IDE integration
  continue     [available] Continue.dev for VS Code
  aider        [installed] Aider CLI integration
  zed          [available] Zed Editor integration
  git-hooks    [installed] Pre-commit validation

# Update all installed rules to latest
$ specsafe rules update
âœ“ Updated cursor rules to v1.2.0
âœ“ Updated aider rules to v1.1.0
âœ“ Updated git-hooks to v1.0.5
```

## Technical Design

### Detection Logic

```typescript
interface ToolDetection {
  name: string;
  configFiles: string[];
  detect(): boolean;
  generateConfig(): Promise<void>;
}

const tools: ToolDetection[] = [
  {
    name: 'cursor',
    configFiles: ['.cursorrules', '.cursor/rules.md'],
    detect() { return fs.existsSync('.cursorrules'); },
    async generateConfig() { /* ... */ }
  },
  {
    name: 'continue',
    configFiles: ['.continue/config.json'],
    detect() { return fs.existsSync('.continue/config.json'); },
    async generateConfig() { /* ... */ }
  },
  // ...
];
```

### Rules Repository Structure

```
specsafe/
â””â”€â”€ rules/
    â”œâ”€â”€ cursor/
    â”‚   â”œâ”€â”€ v1.0.0/
    â”‚   â”‚   â”œâ”€â”€ .cursorrules
    â”‚   â”‚   â””â”€â”€ rules.md
    â”‚   â””â”€â”€ latest/ â†’ v1.0.0/
    â”œâ”€â”€ continue/
    â”‚   â”œâ”€â”€ v1.0.0/
    â”‚   â”‚   â”œâ”€â”€ config.json
    â”‚   â”‚   â””â”€â”€ rules.md
    â”‚   â””â”€â”€ latest/ â†’ v1.0.0/
    â””â”€â”€ manifest.json
```

### Configuration Schema Updates

```json
// specsafe.config.json
{
  "project": "my-project",
  "testFramework": "vitest",
  "tools": {
    "cursor": {
      "enabled": true,
      "version": "1.0.0"
    },
    "aider": {
      "enabled": true,
      "version": "1.0.0"
    }
  },
  "gitHooks": {
    "enabled": true,
    "validateOnCommit": true
  }
}
```

## Tool-Specific Configurations

### Cursor IDE

**`.cursorrules`:**
```markdown
# SpecSafe Rules for Cursor

You are working on a SpecSafe project. Follow these rules:

## Always Check PROJECT_STATE.md
Before making changes, read PROJECT_STATE.md to understand:
- Current active specs and their stages
- Which spec is being worked on
- Requirements that must be satisfied

## Spec-Driven Workflow
1. Specs define WHAT to build (requirements, scenarios)
2. Tests define HOW to verify (generated by SpecSafe)
3. Implementation satisfies tests

## Stage-Aware Development
- SPEC stage: Generate tests from requirements
- TEST stage: Tests exist, implement code to pass them
- CODE stage: Implementation in progress, maintain tests
- QA stage: Validate against scenarios
- COMPLETE: Feature done, archive spec

## Never
- Skip tests to implement faster
- Modify specs without updating PROJECT_STATE.md
- Commit code without corresponding spec entry

## Always
- Run tests before marking work complete
- Update spec stage using `specsafe` commands
- Reference spec ID in commit messages
```

### Continue.dev

**`.continue/config.json`:**
```json
{
  "customCommands": [
    {
      "name": "specsafe",
      "description": "Show current SpecSafe status",
      "prompt": "Read PROJECT_STATE.md and show me the current active specs, their stages, and what needs to be done next."
    },
    {
      "name": "spec",
      "description": "Show details for a specific spec",
      "prompt": "Read the spec file for {{input}} from specs/active/ and show me its requirements, scenarios, and current stage."
    }
  ],
  "contextProviders": [
    {
      "name": "specsafe-state",
      "params": {
        "file": "PROJECT_STATE.md"
      }
    }
  ]
}
```

### Aider CLI

**`.aider.conf.yml`:**
```yaml
# Aider configuration for SpecSafe projects

# Always read PROJECT_STATE.md for context
read:
  - PROJECT_STATE.md

# Instructions for the AI
assistant_prompt: |
  You are working on a SpecSafe project. Always:
  1. Check PROJECT_STATE.md for current specs and stages
  2. Ensure implementation satisfies test requirements
  3. Update spec stage using specsafe commands when complete
  4. Never skip tests or modify specs without tracking

# Files to ignore
ignore:
  - specs/archive/
  - node_modules/
  - dist/
  - .git/
```

### Git Hooks

**`.githooks/pre-commit`:**
```bash
#!/bin/bash
# SpecSafe pre-commit hook

echo "ğŸ” Running SpecSafe pre-commit checks..."

# Validate PROJECT_STATE.md exists
if [ ! -f "PROJECT_STATE.md" ]; then
  echo "âŒ PROJECT_STATE.md not found. Run 'specsafe init' first."
  exit 1
fi

# Run spec validation (if we add a validate command)
# specsafe validate --silent || exit 1

echo "âœ… Pre-commit checks passed"
```

## Implementation Plan

### Phase 1: Core Infrastructure
1. Create `rules/` directory in specsafe repo
2. Implement tool detection logic
3. Add `specsafe rules` command structure

### Phase 2: Tool Integrations
1. Cursor IDE rules
2. Continue.dev rules
3. Aider CLI rules
4. Git hooks

### Phase 3: Interactive Init
1. Update `specsafe init` with prompts
2. Add detection for existing tool configs
3. Generate tool-specific configs

### Phase 4: Updates & Maintenance
1. `specsafe rules update` command
2. Version checking and notifications
3. Rule conflict resolution

## Success Criteria

- [ ] `specsafe init` detects existing tools automatically
- [ ] User can add/remove tool integrations via CLI
- [ ] Each tool has clear, actionable rules for spec-driven workflow
- [ ] Git hooks prevent invalid commits
- [ ] Rules can be updated independently of SpecSafe CLI

## Open Questions

1. Should we support tool-specific commands (e.g., `specsafe cursor status`)?
2. How to handle rule conflicts when multiple tools have different conventions?
3. Should rules be versioned independently or tied to SpecSafe versions?
