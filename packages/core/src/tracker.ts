/**
 * SpecSafe Project State Tracker
 * Manages PROJECT_STATE.md for tracking all specs
 */

import { writeFile, readFile, access } from 'fs/promises';
import { join } from 'path';
import type { Spec, ProjectState, SpecSummary, ProjectMetrics } from './types.js';

export class ProjectTracker {
  private projectPath: string;
  private stateFile: string;

  constructor(projectPath: string) {
    this.projectPath = projectPath;
    this.stateFile = join(projectPath, 'PROJECT_STATE.md');
  }

  /**
   * Initialize a new PROJECT_STATE.md
   */
  async initialize(projectName: string): Promise<void> {
    const state: ProjectState = {
      projectName,
      version: '1.0.0',
      lastUpdated: new Date(),
      specs: [],
      metrics: {
        totalSpecs: 0,
        byStage: {
          spec: 0,
          test: 0,
          code: 0,
          qa: 0,
          complete: 0,
          archived: 0
        },
        completionRate: 0,
        averageCycleTime: 0
      }
    };

    await this.writeState(state);
  }

  /**
   * Read current project state
   */
  async readState(): Promise<ProjectState | null> {
    try {
      await access(this.stateFile);
      const content = await readFile(this.stateFile, 'utf-8');
      return this.parseMarkdown(content);
    } catch {
      return null;
    }
  }

  /**
   * Update PROJECT_STATE.md with new spec
   */
  async addSpec(spec: Spec): Promise<void> {
    const state = await this.readState() || await this.createDefaultState();
    
    const summary: SpecSummary = {
      id: spec.id,
      name: spec.name,
      stage: spec.stage,
      progress: this.calculateProgress(spec),
      lastUpdated: spec.updatedAt
    };

    // Update or add spec
    const existingIndex = state.specs.findIndex(s => s.id === spec.id);
    if (existingIndex >= 0) {
      state.specs[existingIndex] = summary;
    } else {
      state.specs.push(summary);
    }

    state.lastUpdated = new Date();
    state.metrics = this.calculateMetrics(state.specs);

    await this.writeState(state);
  }

  /**
   * Write state to PROJECT_STATE.md
   */
  private async writeState(state: ProjectState): Promise<void> {
    const markdown = this.generateMarkdown(state);
    await writeFile(this.stateFile, markdown, 'utf-8');
  }

  /**
   * Generate markdown content
   */
  private generateMarkdown(state: ProjectState): string {
    const date = state.lastUpdated.toISOString().split('T')[0];
    
    return `# ${state.projectName} - Project State

**Version:** ${state.version}  
**Last Updated:** ${date}

---

## ðŸ“Š Metrics

| Metric | Value |
|--------|-------|
| Total Specs | ${state.metrics.totalSpecs} |
| Completion Rate | ${(state.metrics.completionRate * 100).toFixed(1)}% |
| Avg Cycle Time | ${state.metrics.averageCycleTime.toFixed(1)} days |

### By Stage

| Stage | Count | Percentage |
|-------|-------|------------|
| SPEC | ${state.metrics.byStage.spec} | ${this.getPercentage(state.metrics.byStage.spec, state.metrics.totalSpecs)}% |
| TEST | ${state.metrics.byStage.test} | ${this.getPercentage(state.metrics.byStage.test, state.metrics.totalSpecs)}% |
| CODE | ${state.metrics.byStage.code} | ${this.getPercentage(state.metrics.byStage.code, state.metrics.totalSpecs)}% |
| QA | ${state.metrics.byStage.qa} | ${this.getPercentage(state.metrics.byStage.qa, state.metrics.totalSpecs)}% |
| COMPLETE | ${state.metrics.byStage.complete} | ${this.getPercentage(state.metrics.byStage.complete, state.metrics.totalSpecs)}% |
| ARCHIVED | ${state.metrics.byStage.archived} | ${this.getPercentage(state.metrics.byStage.archived, state.metrics.totalSpecs)}% |

---

## ðŸ“‹ Active Specs

${this.generateSpecsTable(state.specs)}

---

*This file is auto-generated by SpecSafe*
`;
  }

  private generateSpecsTable(specs: SpecSummary[]): string {
    if (specs.length === 0) return 'No specs yet.';

    const rows = specs
      .sort((a, b) => b.lastUpdated.getTime() - a.lastUpdated.getTime())
      .map(s => `| ${s.id} | ${s.name} | ${s.stage.toUpperCase()} | ${s.progress}% | ${s.lastUpdated.toISOString().split('T')[0]} |`)
      .join('\n');

    return `| ID | Name | Stage | Progress | Last Updated |
|----|------|-------|----------|--------------|
${rows}`;
  }

  private getPercentage(count: number, total: number): string {
    if (total === 0) return '0.0';
    return ((count / total) * 100).toFixed(1);
  }

  private calculateProgress(spec: Spec): number {
    const stageWeights: Record<string, number> = {
      spec: 20,
      test: 40,
      code: 60,
      qa: 80,
      complete: 100,
      archived: 100
    };
    return stageWeights[spec.stage] || 0;
  }

  private calculateMetrics(specs: SpecSummary[]): ProjectMetrics {
    const total = specs.length;
    const byStage = {
      spec: specs.filter(s => s.stage === 'spec').length,
      test: specs.filter(s => s.stage === 'test').length,
      code: specs.filter(s => s.stage === 'code').length,
      qa: specs.filter(s => s.stage === 'qa').length,
      complete: specs.filter(s => s.stage === 'complete').length,
      archived: specs.filter(s => s.stage === 'archived').length
    };

    const completionRate = total > 0 ? byStage.complete / total : 0;

    return {
      totalSpecs: total,
      byStage,
      completionRate,
      averageCycleTime: 0 // TODO: Calculate from actual cycle times
    };
  }

  private parseMarkdown(content: string): ProjectState | null {
    // Simple parsing - could be enhanced
    return null;
  }

  private async createDefaultState(): Promise<ProjectState> {
    return {
      projectName: 'Untitled Project',
      version: '1.0.0',
      lastUpdated: new Date(),
      specs: [],
      metrics: {
        totalSpecs: 0,
        byStage: { spec: 0, test: 0, code: 0, qa: 0, complete: 0, archived: 0 },
        completionRate: 0,
        averageCycleTime: 0
      }
    };
  }
}