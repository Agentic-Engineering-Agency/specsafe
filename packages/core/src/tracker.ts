/**
 * SpecSafe Project State Tracker
 * Manages PROJECT_STATE.md for tracking all specs
 */

import { writeFile, readFile, access } from 'fs/promises';
import { join } from 'path';
import type { Spec, ProjectState, SpecSummary, ProjectMetrics, SpecStage } from './types.js';

export class ProjectTracker {
  private projectPath: string;
  private stateFile: string;

  constructor(projectPath: string) {
    this.projectPath = projectPath;
    this.stateFile = join(projectPath, 'PROJECT_STATE.md');
  }

  /**
   * Initialize a new PROJECT_STATE.md
   */
  async initialize(projectName: string): Promise<void> {
    const state: ProjectState = {
      projectName,
      version: '1.0.0',
      lastUpdated: new Date(),
      specs: [],
      metrics: {
        totalSpecs: 0,
        byStage: {
          spec: 0,
          test: 0,
          code: 0,
          qa: 0,
          complete: 0,
          archived: 0
        },
        completionRate: 0,
        averageCycleTime: 0
      }
    };

    await this.writeState(state);
  }

  /**
   * Read current project state
   */
  async readState(): Promise<ProjectState | null> {
    try {
      await access(this.stateFile);
      const content = await readFile(this.stateFile, 'utf-8');
      const parsed = this.parseMarkdown(content);
      if (parsed === null && content.length > 0) {
        throw new Error('Failed to parse PROJECT_STATE.md - file exists but is malformed');
      }
      return parsed;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        return null;
      }
      throw error;
    }
  }

  /**
   * Update PROJECT_STATE.md with new spec
   */
  async addSpec(spec: Spec): Promise<void> {
    const state = await this.readState() || await this.createDefaultState();
    
    const summary: SpecSummary = {
      id: spec.id,
      name: spec.name,
      stage: spec.stage,
      progress: this.calculateProgress(spec),
      lastUpdated: spec.updatedAt,
      createdAt: spec.createdAt,
      completedAt: spec.completedAt
    };

    // Update or add spec
    const existingIndex = state.specs.findIndex(s => s.id === spec.id);
    if (existingIndex >= 0) {
      // Preserve createdAt from existing summary if not set
      if (!summary.createdAt && state.specs[existingIndex].createdAt) {
        summary.createdAt = state.specs[existingIndex].createdAt;
      }
      state.specs[existingIndex] = summary;
    } else {
      state.specs.push(summary);
    }

    state.lastUpdated = new Date();
    state.metrics = this.calculateMetrics(state.specs);

    await this.writeState(state);
  }

  /**
   * Write state to PROJECT_STATE.md
   */
  private async writeState(state: ProjectState): Promise<void> {
    const markdown = this.generateMarkdown(state);
    await writeFile(this.stateFile, markdown, 'utf-8');
  }

  /**
   * Generate markdown content
   */
  private generateMarkdown(state: ProjectState): string {
    const date = state.lastUpdated.toISOString().split('T')[0];
    
    return `# ${state.projectName} - Project State

**Version:** ${state.version}  
**Last Updated:** ${date}

---

## ðŸ“Š Metrics

| Metric | Value |
|--------|-------|
| Total Specs | ${state.metrics.totalSpecs} |
| Completion Rate | ${(state.metrics.completionRate * 100).toFixed(1)}% |
| Avg Cycle Time | ${state.metrics.averageCycleTime.toFixed(1)} days |

### By Stage

| Stage | Count | Percentage |
|-------|-------|------------|
| SPEC | ${state.metrics.byStage.spec} | ${this.getPercentage(state.metrics.byStage.spec, state.metrics.totalSpecs)}% |
| TEST | ${state.metrics.byStage.test} | ${this.getPercentage(state.metrics.byStage.test, state.metrics.totalSpecs)}% |
| CODE | ${state.metrics.byStage.code} | ${this.getPercentage(state.metrics.byStage.code, state.metrics.totalSpecs)}% |
| QA | ${state.metrics.byStage.qa} | ${this.getPercentage(state.metrics.byStage.qa, state.metrics.totalSpecs)}% |
| COMPLETE | ${state.metrics.byStage.complete} | ${this.getPercentage(state.metrics.byStage.complete, state.metrics.totalSpecs)}% |
| ARCHIVED | ${state.metrics.byStage.archived} | ${this.getPercentage(state.metrics.byStage.archived, state.metrics.totalSpecs)}% |

---

## ðŸ“‹ Active Specs

${this.generateSpecsTable(state.specs)}

---

*This file is auto-generated by SpecSafe*
`;
  }

  private generateSpecsTable(specs: SpecSummary[]): string {
    if (specs.length === 0) return 'No specs yet.';

    const rows = specs
      .sort((a, b) => b.lastUpdated.getTime() - a.lastUpdated.getTime())
      .map(s => `| ${s.id} | ${s.name} | ${s.stage.toUpperCase()} | ${s.progress}% | ${s.lastUpdated.toISOString().split('T')[0]} |`)
      .join('\n');

    return `| ID | Name | Stage | Progress | Last Updated |
|----|------|-------|----------|--------------|
${rows}`;
  }

  private getPercentage(count: number, total: number): string {
    if (total === 0) return '0.0';
    return ((count / total) * 100).toFixed(1);
  }

  private calculateProgress(spec: Spec): number {
    const stageWeights: Record<string, number> = {
      spec: 20,
      test: 40,
      code: 60,
      qa: 80,
      complete: 100,
      archived: 100
    };
    return stageWeights[spec.stage] || 0;
  }

  private calculateMetrics(specs: SpecSummary[]): ProjectMetrics {
    const total = specs.length;
    const byStage = {
      spec: specs.filter(s => s.stage === 'spec').length,
      test: specs.filter(s => s.stage === 'test').length,
      code: specs.filter(s => s.stage === 'code').length,
      qa: specs.filter(s => s.stage === 'qa').length,
      complete: specs.filter(s => s.stage === 'complete').length,
      archived: specs.filter(s => s.stage === 'archived').length
    };

    const completionRate = total > 0 ? byStage.complete / total : 0;

    // Calculate average cycle time for completed specs (in days)
    let totalCycleTime = 0;
    let completedCount = 0;
    
    for (const spec of specs) {
      if ((spec.stage === 'complete' || spec.stage === 'archived') && spec.completedAt && spec.createdAt) {
        const cycleTime = spec.completedAt.getTime() - spec.createdAt.getTime();
        totalCycleTime += cycleTime;
        completedCount++;
      }
    }
    
    const averageCycleTime = completedCount > 0 
      ? totalCycleTime / completedCount / (1000 * 60 * 60 * 24)
      : 0;

    return {
      totalSpecs: total,
      byStage,
      completionRate,
      averageCycleTime
    };
  }

  private parseMarkdown(content: string): ProjectState | null {
    try {
      // Extract project name from header
      const nameMatch = content.match(/^#\s+(.+?)\s+-\s+Project\s+State/m);
      const projectName = nameMatch ? nameMatch[1] : 'Untitled Project';
      
      // Extract version
      const versionMatch = content.match(/\*\*Version:\*\*\s*(.+)/m);
      const version = versionMatch ? versionMatch[1].trim() : '1.0.0';
      
      // Extract specs from table
      const specs: SpecSummary[] = [];
      const tableRegex = /\|\s*(SPEC-\d+-\d+)\s*\|\s*([^|]+)\|\s*(SPEC|TEST|CODE|QA|COMPLETE|ARCHIVED)\s*\|\s*(\d+)%?\s*\|\s*(\d{4}-\d{2}-\d{2})\s*\|/gi;
      let match;
      while ((match = tableRegex.exec(content)) !== null) {
        specs.push({
          id: match[1].trim(),
          name: match[2].trim(),
          stage: match[3].toLowerCase() as SpecStage,
          progress: parseInt(match[4], 10),
          lastUpdated: new Date(match[5])
        });
      }
      
      // Calculate metrics
      const metrics = this.calculateMetrics(specs);
      
      return {
        projectName,
        version,
        lastUpdated: new Date(),
        specs,
        metrics
      };
    } catch {
      return null;
    }
  }
  
  /**
   * Load all specs from PROJECT_STATE.md into a Workflow instance
   */
  async loadSpecsIntoWorkflow(workflow: any): Promise<void> {
    const state = await this.readState();
    if (!state) return;
    
    for (const summary of state.specs) {
      // Try to read the actual spec file for full details
      const specPath = join(this.projectPath, 'specs', summary.stage === 'complete' || summary.stage === 'archived' ? 'completed' : 'active', `${summary.id}.md`);
      try {
        const content = await readFile(specPath, 'utf-8');
        // Create a minimal spec object with the data we have
        const spec: Spec = {
          id: summary.id,
          name: summary.name,
          description: '', // Would need to parse from markdown
          stage: summary.stage,
          createdAt: summary.lastUpdated,
          updatedAt: summary.lastUpdated,
          requirements: [],
          testFiles: [],
          implementationFiles: [],
          metadata: {
            author: '',
            project: '',
            tags: []
          }
        };
        // Inject into workflow's specs map
        workflow.loadSpec(spec);
      } catch {
        // Spec file not found, skip
      }
    }
  }

  private async createDefaultState(): Promise<ProjectState> {
    return {
      projectName: 'Untitled Project',
      version: '1.0.0',
      lastUpdated: new Date(),
      specs: [],
      metrics: {
        totalSpecs: 0,
        byStage: { spec: 0, test: 0, code: 0, qa: 0, complete: 0, archived: 0 },
        completionRate: 0,
        averageCycleTime: 0
      }
    };
  }
}