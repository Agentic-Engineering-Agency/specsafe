/**
 * Stakeholder Bundle Exporter
 * Generate role-specific bundles: executive, technical, qa, design
 */

import type { ParsedSpec, ExportResult, StakeholderBundle } from '../types.js';

/**
 * Generate executive summary - business goals, timeline, risks (no technical details)
 */
function generateExecutiveSummary(spec: ParsedSpec): ExportResult {
  const lines: string[] = [];

  lines.push(`# Executive Summary: ${spec.name}`);
  lines.push('');
  lines.push(`**Spec ID:** ${spec.id}`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Overview
  lines.push('## Overview');
  lines.push('');
  if (spec.description) {
    lines.push(spec.description);
    lines.push('');
  }

  // Business Goals (from PRD)
  if (spec.prd) {
    lines.push('## Business Goals');
    lines.push('');

    if (spec.prd.problemStatement) {
      lines.push('### Problem Statement');
      lines.push('');
      lines.push(spec.prd.problemStatement);
      lines.push('');
    }

    if (spec.prd.userStories?.length) {
      lines.push('### User Stories');
      lines.push('');
      spec.prd.userStories.forEach(story => {
        lines.push(`- ${story}`);
      });
      lines.push('');
    }

    if (spec.prd.acceptanceCriteria?.length) {
      lines.push('### Acceptance Criteria');
      lines.push('');
      spec.prd.acceptanceCriteria.forEach(criterion => {
        lines.push(`- ${criterion}`);
      });
      lines.push('');
    }
  }

  // Requirements Summary
  if (spec.requirements?.length) {
    lines.push('## Requirements Summary');
    lines.push('');
    const p0Count = spec.requirements.filter(r => r.priority === 'P0').length;
    const p1Count = spec.requirements.filter(r => r.priority === 'P1').length;
    const p2Count = spec.requirements.filter(r => r.priority === 'P2').length;

    lines.push(`- **Critical (P0):** ${p0Count}`);
    lines.push(`- **High (P1):** ${p1Count}`);
    lines.push(`- **Medium (P2):** ${p2Count}`);
    lines.push(`- **Total:** ${spec.requirements.length}`);
    lines.push('');

    lines.push('### Key Requirements');
    lines.push('');
    const keyReqs = spec.requirements.filter(r => r.priority === 'P0').slice(0, 5);
    keyReqs.forEach(req => {
      lines.push(`- ${req.text}`);
    });
    if (keyReqs.length === 0 && spec.requirements.length > 0) {
      spec.requirements.slice(0, 3).forEach(req => {
        lines.push(`- ${req.text}`);
      });
    }
    lines.push('');
  }

  // Timeline
  if (spec.timeline) {
    lines.push('## Timeline');
    lines.push('');

    if (spec.timeline.estimatedDuration) {
      lines.push(`**Estimated Duration:** ${spec.timeline.estimatedDuration}`);
      lines.push('');
    }

    if (spec.timeline.milestones?.length) {
      lines.push('### Milestones');
      lines.push('');
      spec.timeline.milestones.forEach((milestone, index) => {
        lines.push(`${index + 1}. ${milestone}`);
      });
      lines.push('');
    }
  }

  // Risks
  if (spec.risks?.length) {
    lines.push('## Risks & Mitigation');
    lines.push('');
    spec.risks.forEach(risk => {
      lines.push(`⚠️ ${risk}`);
    });
    lines.push('');
  }

  // Status
  lines.push('## Status');
  lines.push('');
  lines.push(`**Current Stage:** ${spec.stage.toUpperCase()}`);
  lines.push(`**Last Updated:** ${spec.updatedAt.toISOString().split('T')[0]}`);
  if (spec.completedAt) {
    lines.push(`**Completed:** ${spec.completedAt.toISOString().split('T')[0]}`);
  }
  lines.push('');

  lines.push('---');
  lines.push('');
  lines.push(`*Executive Summary generated by SpecSafe on ${new Date().toISOString()}*`);
  lines.push('');

  const content = lines.join('\n');

  return {
    content,
    filename: `${spec.id.toLowerCase()}-executive-summary.md`,
    mimeType: 'text/markdown',
    size: Buffer.byteLength(content, 'utf-8'),
  };
}

/**
 * Generate technical specification - architecture, APIs, data models (no business context)
 */
function generateTechnicalSpec(spec: ParsedSpec): ExportResult {
  const lines: string[] = [];

  lines.push(`# Technical Specification: ${spec.name}`);
  lines.push('');
  lines.push(`**Spec ID:** ${spec.id}`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Architecture
  if (spec.architecture) {
    lines.push('## Architecture');
    lines.push('');

    if (spec.architecture.overview) {
      lines.push('### Overview');
      lines.push('');
      lines.push(spec.architecture.overview);
      lines.push('');
    }

    if (spec.architecture.components?.length) {
      lines.push('### Components');
      lines.push('');
      spec.architecture.components.forEach((component, index) => {
        lines.push(`${index + 1}. ${component}`);
      });
      lines.push('');
    }

    if (spec.architecture.dataModels?.length) {
      lines.push('### Data Models');
      lines.push('');
      spec.architecture.dataModels.forEach((model, index) => {
        lines.push(`\`${model}\``);
        lines.push('');
      });
    }
  }

  // APIs
  if (spec.architecture?.apis?.length) {
    lines.push('## API Specification');
    lines.push('');

    spec.architecture.apis.forEach(api => {
      lines.push(`### ${api.name}`);
      lines.push('');
      if (api.method) {
        lines.push(`**Method:** \`${api.method}\``);
        lines.push('');
      }
      if (api.endpoint) {
        lines.push(`**Endpoint:** \`${api.endpoint}\``);
        lines.push('');
      }
      if (api.description) {
        lines.push('**Description:**');
        lines.push(api.description);
        lines.push('');
      }
    });
  }

  // Technical Requirements
  if (spec.requirements?.length) {
    lines.push('## Technical Requirements');
    lines.push('');
    lines.push('| ID | Requirement | Priority |');
    lines.push('|----|-------------|----------|');
    spec.requirements.forEach(req => {
      lines.push(`| ${req.id} | ${req.text} | ${req.priority} |`);
    });
    lines.push('');
  }

  // Scenarios (technical test cases)
  if (spec.scenarios?.length) {
    lines.push('## Test Scenarios');
    lines.push('');
    spec.scenarios.forEach(scenario => {
      lines.push(`### ${scenario.id}: ${scenario.name}`);
      lines.push('');
      lines.push(`- **Given** ${scenario.given}`);
      lines.push(`- **When** ${scenario.when}`);
      lines.push(`- **Then** ${scenario.thenOutcome}`);
      lines.push('');
    });
  }

  // Technical Considerations
  if (spec.prd?.technicalConsiderations) {
    lines.push('## Technical Considerations');
    lines.push('');
    lines.push(spec.prd.technicalConsiderations);
    lines.push('');
  }

  lines.push('---');
  lines.push('');
  lines.push(`*Technical Specification generated by SpecSafe on ${new Date().toISOString()}*`);
  lines.push('');

  const content = lines.join('\n');

  return {
    content,
    filename: `${spec.id.toLowerCase()}-technical-spec.md`,
    mimeType: 'text/markdown',
    size: Buffer.byteLength(content, 'utf-8'),
  };
}

/**
 * Generate QA view - requirements, acceptance criteria, test scenarios
 */
function generateQASpec(spec: ParsedSpec): ExportResult {
  const lines: string[] = [];

  lines.push(`# QA Specification: ${spec.name}`);
  lines.push('');
  lines.push(`**Spec ID:** ${spec.id}`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Requirements for QA
  if (spec.requirements?.length) {
    lines.push('## Requirements');
    lines.push('');

    // Group by priority
    const p0Reqs = spec.requirements.filter(r => r.priority === 'P0');
    const p1Reqs = spec.requirements.filter(r => r.priority === 'P1');
    const p2Reqs = spec.requirements.filter(r => r.priority === 'P2');

    if (p0Reqs.length > 0) {
      lines.push('### P0 (Critical) Requirements');
      lines.push('');
      lines.push('| ID | Requirement |');
      lines.push('|----|-------------|');
      p0Reqs.forEach(req => {
        lines.push(`| ${req.id} | ${req.text} |`);
      });
      lines.push('');
    }

    if (p1Reqs.length > 0) {
      lines.push('### P1 (High) Requirements');
      lines.push('');
      lines.push('| ID | Requirement |');
      lines.push('|----|-------------|');
      p1Reqs.forEach(req => {
        lines.push(`| ${req.id} | ${req.text} |`);
      });
      lines.push('');
    }

    if (p2Reqs.length > 0) {
      lines.push('### P2 (Medium) Requirements');
      lines.push('');
      lines.push('| ID | Requirement |');
      lines.push('|----|-------------|');
      p2Reqs.forEach(req => {
        lines.push(`| ${req.id} | ${req.text} |`);
      });
      lines.push('');
    }
  }

  // Acceptance Criteria
  if (spec.prd?.acceptanceCriteria?.length) {
    lines.push('## Acceptance Criteria');
    lines.push('');
    spec.prd.acceptanceCriteria.forEach((criterion, index) => {
      lines.push(`${index + 1}. ${criterion}`);
    });
    lines.push('');
  }

  // Test Scenarios
  const allScenarios: Array<{ id: string; name: string; given: string; when: string; thenOutcome: string }> = [];

  if (spec.scenarios?.length) {
    allScenarios.push(...spec.scenarios);
  }

  if (spec.requirements?.length) {
    spec.requirements.forEach(req => {
      if (req.scenarios?.length) {
        req.scenarios.forEach(scenario => {
          allScenarios.push({
            ...scenario,
            name: `${req.id}: ${scenario.id}`,
          });
        });
      }
    });
  }

  if (allScenarios.length > 0) {
    lines.push('## Test Scenarios');
    lines.push('');

    allScenarios.forEach(scenario => {
      lines.push(`### ${scenario.id}: ${scenario.name}`);
      lines.push('');
      lines.push('**Given** ' + scenario.given);
      lines.push('**When** ' + scenario.when);
      lines.push('**Then** ' + scenario.thenOutcome);
      lines.push('');
    });
  }

  // Test Results
  if (spec.testResults) {
    lines.push('## Test Results');
    lines.push('');
    lines.push('| Status | Count |');
    lines.push('|--------|-------|');
    lines.push(`| ✅ Passed | ${spec.testResults.passed} |`);
    lines.push(`| ❌ Failed | ${spec.testResults.failed} |`);
    lines.push(`| ⏭️ Skipped | ${spec.testResults.skipped} |`);
    lines.push('');

    if (spec.testResults.coverage) {
      lines.push('### Coverage');
      lines.push('');
      lines.push('| Type | Percentage |');
      lines.push('|------|------------|');
      lines.push(`| Statements | ${spec.testResults.coverage.statements}% |`);
      lines.push(`| Branches | ${spec.testResults.coverage.branches}% |`);
      lines.push(`| Functions | ${spec.testResults.coverage.functions}% |`);
      lines.push(`| Lines | ${spec.testResults.coverage.lines}% |`);
      lines.push('');
    }
  }

  // User Stories for QA testing
  if (spec.prd?.userStories?.length) {
    lines.push('## User Stories for QA');
    lines.push('');
    spec.prd.userStories.forEach((story, index) => {
      lines.push(`${index + 1}. ${story}`);
    });
    lines.push('');
  }

  lines.push('---');
  lines.push('');
  lines.push(`*QA Specification generated by SpecSafe on ${new Date().toISOString()}*`);
  lines.push('');

  const content = lines.join('\n');

  return {
    content,
    filename: `${spec.id.toLowerCase()}-qa-spec.md`,
    mimeType: 'text/markdown',
    size: Buffer.byteLength(content, 'utf-8'),
  };
}

/**
 * Generate design view - UX flows, UI requirements, accessibility
 */
function generateDesignSpec(spec: ParsedSpec): ExportResult {
  const lines: string[] = [];

  lines.push(`# Design Specification: ${spec.name}`);
  lines.push('');
  lines.push(`**Spec ID:** ${spec.id}`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Overview
  lines.push('## Overview');
  lines.push('');
  if (spec.description) {
    lines.push(spec.description);
    lines.push('');
  }
  lines.push('This document outlines the UX flows, UI requirements, and accessibility standards for the feature.');
  lines.push('');

  // UX Flows
  if (spec.design?.uxFlows?.length) {
    lines.push('## UX Flows');
    lines.push('');
    spec.design.uxFlows.forEach((flow, index) => {
      lines.push(`### Flow ${index + 1}`);
      lines.push('');
      lines.push(flow);
      lines.push('');
    });
  }

  // UI Requirements
  if (spec.design?.uiRequirements?.length) {
    lines.push('## UI Requirements');
    lines.push('');
    spec.design.uiRequirements.forEach((req, index) => {
      lines.push(`${index + 1}. ${req}`);
    });
    lines.push('');
  }

  // Accessibility
  if (spec.design?.accessibility?.length) {
    lines.push('## Accessibility');
    lines.push('');
    spec.design.accessibility.forEach((item, index) => {
      lines.push(`${index + 1}. ${item}`);
    });
    lines.push('');
  }

  // User Stories (inform design)
  if (spec.prd?.userStories?.length) {
    lines.push('## User Stories');
    lines.push('');
    lines.push('These user stories inform the design decisions:');
    lines.push('');
    spec.prd.userStories.forEach(story => {
      lines.push(`- ${story}`);
    });
    lines.push('');
  }

  // Screens/Components (extracted from requirements if available)
  if (spec.requirements?.length) {
    lines.push('## Design Considerations from Requirements');
    lines.push('');
    const designReqs = spec.requirements.filter(req =>
      req.text.toLowerCase().includes('ui') ||
      req.text.toLowerCase().includes('interface') ||
      req.text.toLowerCase().includes('display') ||
      req.text.toLowerCase().includes('show') ||
      req.text.toLowerCase().includes('user')
    );

    if (designReqs.length > 0) {
      designReqs.forEach(req => {
        lines.push(`**${req.id}:** ${req.text}`);
        lines.push('');
      });
    } else {
      lines.push('*No UI-specific requirements identified. Review all requirements for design implications.*');
      lines.push('');
    }
  }

  // Scenarios (inform UX flows)
  if (spec.scenarios?.length) {
    lines.push('## User Scenarios (UX Context)');
    lines.push('');
    spec.scenarios.forEach(scenario => {
      lines.push(`### ${scenario.id}: ${scenario.name}`);
      lines.push('');
      lines.push(`**User Intent:** ${scenario.given} → ${scenario.when} → ${scenario.thenOutcome}`);
      lines.push('');
    });
  }

  // WCAG Standards
  lines.push('## Accessibility Standards');
  lines.push('');
  lines.push('Design should adhere to WCAG 2.1 Level AA standards:');
  lines.push('');
  lines.push('- **Perceivable:** Information and UI components must be presentable in ways users can perceive.');
  lines.push('- **Operable:** UI components and navigation must be operable.');
  lines.push('- **Understandable:** Information and the operation of the UI must be understandable.');
  lines.push('- **Robust:** Content must be robust enough to be interpreted by a wide variety of user agents.');
  lines.push('');

  lines.push('---');
  lines.push('');
  lines.push(`*Design Specification generated by SpecSafe on ${new Date().toISOString()}*`);
  lines.push('');

  const content = lines.join('\n');

  return {
    content,
    filename: `${spec.id.toLowerCase()}-design-spec.md`,
    mimeType: 'text/markdown',
    size: Buffer.byteLength(content, 'utf-8'),
  };
}

/**
 * Generate all stakeholder bundles for a spec
 */
export function generateStakeholderBundle(spec: ParsedSpec): StakeholderBundle {
  return {
    executive: generateExecutiveSummary(spec),
    technical: generateTechnicalSpec(spec),
    qa: generateQASpec(spec),
    design: generateDesignSpec(spec),
  };
}

/**
 * Generate a single stakeholder view
 */
export function generateStakeholderView(
  spec: ParsedSpec,
  role: 'executive' | 'technical' | 'qa' | 'design'
): ExportResult {
  switch (role) {
    case 'executive':
      return generateExecutiveSummary(spec);
    case 'technical':
      return generateTechnicalSpec(spec);
    case 'qa':
      return generateQASpec(spec);
    case 'design':
      return generateDesignSpec(spec);
  }
}
