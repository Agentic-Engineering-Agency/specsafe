import { writeFile, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import chalk from 'chalk';

/**
 * Generates configuration files for AI coding tools
 */

const cursorRulesContent = `# SpecSafe Rules for Cursor

You are working on a SpecSafe project. Follow these rules:

## Always Check PROJECT_STATE.md
Before making changes, read PROJECT_STATE.md to understand:
- Current active specs and their stages
- Which spec is being worked on
- Requirements that must be satisfied

## Spec-Driven Workflow
1. Specs define WHAT to build (requirements, scenarios)
2. Tests define HOW to verify (generated by SpecSafe)
3. Implementation satisfies tests

## Stage-Aware Development
- SPEC stage: Generate tests from requirements
- TEST stage: Tests exist, implement code to pass them
- CODE stage: Implementation in progress, maintain tests
- QA stage: Validate against scenarios
- COMPLETE: Feature done, archive spec

## Never
- Skip tests to implement faster
- Modify specs without updating PROJECT_STATE.md
- Commit code without corresponding spec entry

## Always
- Run tests before marking work complete
- Update spec stage using \`specsafe\` commands
- Reference spec ID in commit messages
`;

const continueConfigContent = {
  customCommands: [
    {
      name: 'specsafe',
      description: 'Show current SpecSafe status',
      prompt: 'Read PROJECT_STATE.md and show me the current active specs, their stages, and what needs to be done next.',
    },
    {
      name: 'spec',
      description: 'Show details for a specific spec',
      prompt: 'Read the spec file for {{input}} from specs/active/ and show me its requirements, scenarios, and current stage.',
    },
  ],
  contextProviders: [
    {
      name: 'specsafe-state',
      params: {
        file: 'PROJECT_STATE.md',
      },
    },
  ],
};

const aiderConfigContent = `# Aider configuration for SpecSafe projects

# Always read PROJECT_STATE.md for context
read:
  - PROJECT_STATE.md

# Instructions for the AI
assistant_prompt: |
  You are working on a SpecSafe project. Always:
  1. Check PROJECT_STATE.md for current specs and stages
  2. Ensure implementation satisfies test requirements
  3. Update spec stage using specsafe commands when complete
  4. Never skip tests or modify specs without tracking

# Files to ignore
ignore:
  - specs/archive/
  - node_modules/
  - dist/
  - .git/
`;

const zedSettingsContent = {
  assistant: {
    default_model: {
      provider: 'anthropic',
      model: 'claude-3-5-sonnet-latest',
    },
    version: '2',
  },
  context_servers: {
    specsafe: {
      command: 'cat',
      args: ['PROJECT_STATE.md'],
    },
  },
};

/**
 * Generate configuration for a specific tool
 * @param tool - The tool name (cursor, continue, aider, zed, claude-code, crush)
 * @param projectDir - The project directory path
 */
export async function generateToolConfig(tool: string, projectDir: string = '.'): Promise<void> {
  switch (tool) {
    case 'cursor':
      await generateCursorConfig(projectDir);
      break;
    case 'continue':
      await generateContinueConfig(projectDir);
      break;
    case 'aider':
      await generateAiderConfig(projectDir);
      break;
    case 'zed':
      await generateZedConfig(projectDir);
      break;
    case 'claude-code':
      await generateClaudeCodeConfig(projectDir);
      break;
    case 'crush':
      await generateCrushConfig(projectDir);
      break;
    default:
      throw new Error(`Unknown tool: ${tool}`);
  }
}

async function generateCursorConfig(projectDir: string): Promise<void> {
  const configPath = `${projectDir}/.cursorrules`;
  
  if (existsSync(configPath)) {
    console.log(chalk.yellow('‚ö† .cursorrules already exists, skipping'));
    return;
  }
  
  await writeFile(configPath, cursorRulesContent);
}

async function generateContinueConfig(projectDir: string): Promise<void> {
  const configDir = `${projectDir}/.continue`;
  const configPath = `${configDir}/config.json`;
  
  if (!existsSync(configDir)) {
    await mkdir(configDir, { recursive: true });
  }
  
  if (existsSync(configPath)) {
    console.log(chalk.yellow('‚ö† .continue/config.json already exists, skipping'));
    return;
  }
  
  await writeFile(configPath, JSON.stringify(continueConfigContent, null, 2));
}

async function generateAiderConfig(projectDir: string): Promise<void> {
  const configPath = `${projectDir}/.aider.conf.yml`;
  
  if (existsSync(configPath)) {
    console.log(chalk.yellow('‚ö† .aider.conf.yml already exists, skipping'));
    return;
  }
  
  await writeFile(configPath, aiderConfigContent);
}

async function generateZedConfig(projectDir: string): Promise<void> {
  const configDir = `${projectDir}/.zed`;
  const configPath = `${configDir}/settings.json`;
  
  if (!existsSync(configDir)) {
    await mkdir(configDir, { recursive: true });
  }
  
  if (existsSync(configPath)) {
    console.log(chalk.yellow('‚ö† .zed/settings.json already exists, skipping'));
    return;
  }
  
  await writeFile(configPath, JSON.stringify(zedSettingsContent, null, 2));
}

// Skill content for Claude Code slash commands
const claudeSkillSpecsafeContent = `---
name: specsafe
description: Show SpecSafe project status and workflow guidance
disable-model-invocation: true
---

You are in a SpecSafe project using spec-driven development.

Read PROJECT_STATE.md and provide:
1. Summary of active specs and their current stages
2. Which specs need attention
3. Recommended next actions based on the project state
4. Brief reminder of the SDD workflow (SPEC ‚Üí TEST ‚Üí CODE ‚Üí QA ‚Üí COMPLETE)
`;

const claudeSkillSpecContent = `---
name: spec
description: Show details for a specific spec by ID
argument-hint: "[spec-id]"
disable-model-invocation: true
---

Read the spec file from specs/active/$ARGUMENTS.md and show:
- Requirements
- Scenarios/acceptance criteria
- Current stage
- Implementation files referenced

If no argument provided, list available specs.
`;

const claudeSkillValidateContent = `---
name: validate
description: Validate current implementation against active spec
disable-model-invocation: true
---

Check if the current code changes satisfy the requirements in the active spec.
Point out any gaps or issues that need to be addressed before completing.
`;

async function generateClaudeCodeConfig(projectDir: string): Promise<void> {
  // Create CLAUDE.md project context file
  const configPath = `${projectDir}/CLAUDE.md`;
  
  if (!existsSync(configPath)) {
    const claudeContent = `# SpecSafe Project ‚Äî Claude Code Configuration

You are working on a SpecSafe project using spec-driven development (SDD).

## Project Context

**PROJECT_STATE.md** ‚Äî Always read this file first. It contains:
- Active specs and their current stages
- Which spec is being worked on
- Overall project status

**Specs directory** ‚Äî \`specs/active/*.md\` contains detailed spec files with:
- Requirements (must be satisfied)
- Scenarios (acceptance criteria)
- Current stage (SPEC ‚Üí TEST ‚Üí CODE ‚Üí QA ‚Üí COMPLETE)

## Spec-Driven Development Workflow

1. **SPEC stage**: Spec defines WHAT to build (requirements, scenarios)
2. **TEST stage**: Tests define HOW to verify (generated by SpecSafe)
3. **CODE stage**: Implementation satisfies the tests
4. **QA stage**: Validate against scenarios, edge cases
5. **COMPLETE**: Feature done, spec archived

## Critical Rules

‚úÖ **ALWAYS** read PROJECT_STATE.md before making changes  
‚úÖ **ALWAYS** ensure implementation satisfies tests  
‚úÖ **ALWAYS** use \`specsafe\` CLI commands to advance stages  
‚úÖ **ALWAYS** reference spec ID in commit messages  

‚ùå **NEVER** modify PROJECT_STATE.md directly (use CLI)  
‚ùå **NEVER** skip tests to implement faster  
‚ùå **NEVER** modify specs without updating state

## SpecSafe CLI Reference

- \`specsafe status\` ‚Äî Show current project status
- \`specsafe spec <id>\` ‚Äî View spec details, move to SPEC stage
- \`specsafe test <id>\` ‚Äî Generate tests, move to TEST stage
- \`specsafe code <id>\` ‚Äî Start implementation, move to CODE stage
- \`specsafe qa <id>\` ‚Äî Run QA validation, move to QA stage
- \`specsafe complete <id>\` ‚Äî Complete spec, move to COMPLETE stage

## Claude Code Skills

This project includes Claude Code skills for slash commands:
- \`/specsafe\` ‚Äî Show project status and workflow guidance
- \`/spec <id>\` ‚Äî Show details for a specific spec
- \`/validate\` ‚Äî Validate implementation against active spec
`;
    
    await writeFile(configPath, claudeContent);
    console.log(chalk.green('‚úì Created CLAUDE.md'));
  } else {
    console.log(chalk.yellow('‚ö† CLAUDE.md already exists, skipping'));
  }

  // Create .claude/skills/ directory with SKILL.md files for slash commands
  const skillsDir = `${projectDir}/.claude/skills`;
  
  if (!existsSync(skillsDir)) {
    await mkdir(skillsDir, { recursive: true });
  }

  // Create specsafe skill
  const specsafeSkillDir = `${skillsDir}/specsafe`;
  const specsafeSkillPath = `${specsafeSkillDir}/SKILL.md`;
  if (!existsSync(specsafeSkillPath)) {
    if (!existsSync(specsafeSkillDir)) {
      await mkdir(specsafeSkillDir, { recursive: true });
    }
    await writeFile(specsafeSkillPath, claudeSkillSpecsafeContent);
    console.log(chalk.green('‚úì Created .claude/skills/specsafe/SKILL.md'));
  } else {
    console.log(chalk.yellow('‚ö† .claude/skills/specsafe/SKILL.md already exists, skipping'));
  }

  // Create spec skill
  const specSkillDir = `${skillsDir}/spec`;
  const specSkillPath = `${specSkillDir}/SKILL.md`;
  if (!existsSync(specSkillPath)) {
    if (!existsSync(specSkillDir)) {
      await mkdir(specSkillDir, { recursive: true });
    }
    await writeFile(specSkillPath, claudeSkillSpecContent);
    console.log(chalk.green('‚úì Created .claude/skills/spec/SKILL.md'));
  } else {
    console.log(chalk.yellow('‚ö† .claude/skills/spec/SKILL.md already exists, skipping'));
  }

  // Create validate skill
  const validateSkillDir = `${skillsDir}/validate`;
  const validateSkillPath = `${validateSkillDir}/SKILL.md`;
  if (!existsSync(validateSkillPath)) {
    if (!existsSync(validateSkillDir)) {
      await mkdir(validateSkillDir, { recursive: true });
    }
    await writeFile(validateSkillPath, claudeSkillValidateContent);
    console.log(chalk.green('‚úì Created .claude/skills/validate/SKILL.md'));
  } else {
    console.log(chalk.yellow('‚ö† .claude/skills/validate/SKILL.md already exists, skipping'));
  }
}

async function generateCrushConfig(projectDir: string): Promise<void> {
  const configPath = `${projectDir}/CRUSH.md`;
  
  if (existsSync(configPath)) {
    console.log(chalk.yellow('‚ö† CRUSH.md already exists, skipping'));
    return;
  }
  
  const crushContent = `# SpecSafe Project ‚Äî Crush Configuration

You are working on a SpecSafe project using spec-driven development (SDD).

## Project Context

**PROJECT_STATE.md** ‚Äî Always read this file first. It contains:
- Active specs and their current stages
- Which spec is being worked on  
- Overall project status

**Specs directory** ‚Äî \`specs/active/*.md\` contains detailed spec files with:
- Requirements (must be satisfied)
- Scenarios (acceptance criteria)
- Current stage (SPEC ‚Üí TEST ‚Üí CODE ‚Üí QA ‚Üí COMPLETE)

## Spec-Driven Development Workflow

1. **SPEC stage**: Spec defines WHAT to build
2. **TEST stage**: Tests define HOW to verify
3. **CODE stage**: Implementation satisfies tests
4. **QA stage**: Validate against scenarios
5. **COMPLETE**: Feature done

## Rules

- Always check PROJECT_STATE.md before changes
- Use SpecSafe CLI to advance stages
- Never modify PROJECT_STATE.md directly
- Tests define requirements ‚Äî don't skip them
- Reference spec IDs in commits

## CLI Commands

- \`specsafe status\` ‚Äî Project status
- \`specsafe spec|test|code|qa|complete <id>\` ‚Äî Stage transitions
`;
  
  await writeFile(configPath, crushContent);
}

/**
 * Generate git hooks configuration
 * @param projectDir - The project directory path
 */
export async function generateGitHooks(projectDir: string): Promise<void> {
  const hooksDir = `${projectDir}/.githooks`;
  const preCommitPath = `${hooksDir}/pre-commit`;
  
  if (!existsSync(hooksDir)) {
    await mkdir(hooksDir, { recursive: true });
  }
  
  const preCommitContent = `#!/bin/bash
# SpecSafe pre-commit hook

echo "üîç Running SpecSafe pre-commit checks..."

# Validate PROJECT_STATE.md exists
if [ ! -f "PROJECT_STATE.md" ]; then
  echo "‚ùå PROJECT_STATE.md not found. Run 'specsafe init' first."
  exit 1
fi

# Run spec validation (if we add a validate command)
# specsafe validate --silent || exit 1

echo "‚úÖ Pre-commit checks passed"
`;
  
  if (existsSync(preCommitPath)) {
    console.log(chalk.yellow('‚ö† .githooks/pre-commit already exists, skipping'));
    return;
  }
  
  await writeFile(preCommitPath, preCommitContent);
  
  // Make the hook executable (this won't work on Windows without special handling)
  try {
    const { exec } = await import('child_process');
    exec(`chmod +x ${preCommitPath}`);
  } catch {
    // Ignore chmod errors on Windows
  }
}
