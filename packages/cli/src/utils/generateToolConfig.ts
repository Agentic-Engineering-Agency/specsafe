import { writeFile, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import chalk from 'chalk';

/**
 * Generates configuration files for AI coding tools
 */

const cursorRulesContent = `# SpecSafe Rules for Cursor

You are working on a SpecSafe project. Follow these rules:

## Always Check PROJECT_STATE.md
Before making changes, read PROJECT_STATE.md to understand:
- Current active specs and their stages
- Which spec is being worked on
- Requirements that must be satisfied

## Spec-Driven Workflow
1. Specs define WHAT to build (requirements, scenarios)
2. Tests define HOW to verify (generated by SpecSafe)
3. Implementation satisfies tests

## Stage-Aware Development
- SPEC stage: Generate tests from requirements
- TEST stage: Tests exist, implement code to pass them
- CODE stage: Implementation in progress, maintain tests
- QA stage: Validate against scenarios
- COMPLETE: Feature done, archive spec

## Never
- Skip tests to implement faster
- Modify specs without updating PROJECT_STATE.md
- Commit code without corresponding spec entry

## Always
- Run tests before marking work complete
- Update spec stage using \`specsafe\` commands
- Reference spec ID in commit messages
`;

const continueConfigContent = {
  customCommands: [
    {
      name: 'specsafe',
      description: 'Show current SpecSafe status',
      prompt: 'Read PROJECT_STATE.md and show me the current active specs, their stages, and what needs to be done next.',
    },
    {
      name: 'spec',
      description: 'Show details for a specific spec',
      prompt: 'Read the spec file for {{input}} from specs/active/ and show me its requirements, scenarios, and current stage.',
    },
  ],
  contextProviders: [
    {
      name: 'specsafe-state',
      params: {
        file: 'PROJECT_STATE.md',
      },
    },
  ],
};

const aiderConfigContent = `# Aider configuration for SpecSafe projects

# Always read PROJECT_STATE.md for context
read:
  - PROJECT_STATE.md

# Instructions for the AI
assistant_prompt: |
  You are working on a SpecSafe project. Always:
  1. Check PROJECT_STATE.md for current specs and stages
  2. Ensure implementation satisfies test requirements
  3. Update spec stage using specsafe commands when complete
  4. Never skip tests or modify specs without tracking

# Files to ignore
ignore:
  - specs/archive/
  - node_modules/
  - dist/
  - .git/
`;

const zedSettingsContent = {
  assistant: {
    default_model: {
      provider: 'anthropic',
      model: 'claude-3-5-sonnet-latest',
    },
    version: '2',
  },
  context_servers: {
    specsafe: {
      command: 'cat',
      args: ['PROJECT_STATE.md'],
    },
  },
};

/**
 * Generate configuration for a specific tool
 * @param tool - The tool name (cursor, continue, aider, zed)
 * @param projectDir - The project directory path
 */
export async function generateToolConfig(tool: string, projectDir: string = '.'): Promise<void> {
  switch (tool) {
    case 'cursor':
      await generateCursorConfig(projectDir);
      break;
    case 'continue':
      await generateContinueConfig(projectDir);
      break;
    case 'aider':
      await generateAiderConfig(projectDir);
      break;
    case 'zed':
      await generateZedConfig(projectDir);
      break;
    default:
      throw new Error(`Unknown tool: ${tool}`);
  }
}

async function generateCursorConfig(projectDir: string): Promise<void> {
  const configPath = `${projectDir}/.cursorrules`;
  
  if (existsSync(configPath)) {
    console.log(chalk.yellow('‚ö† .cursorrules already exists, skipping'));
    return;
  }
  
  await writeFile(configPath, cursorRulesContent);
}

async function generateContinueConfig(projectDir: string): Promise<void> {
  const configDir = `${projectDir}/.continue`;
  const configPath = `${configDir}/config.json`;
  
  if (!existsSync(configDir)) {
    await mkdir(configDir, { recursive: true });
  }
  
  if (existsSync(configPath)) {
    console.log(chalk.yellow('‚ö† .continue/config.json already exists, skipping'));
    return;
  }
  
  await writeFile(configPath, JSON.stringify(continueConfigContent, null, 2));
}

async function generateAiderConfig(projectDir: string): Promise<void> {
  const configPath = `${projectDir}/.aider.conf.yml`;
  
  if (existsSync(configPath)) {
    console.log(chalk.yellow('‚ö† .aider.conf.yml already exists, skipping'));
    return;
  }
  
  await writeFile(configPath, aiderConfigContent);
}

async function generateZedConfig(projectDir: string): Promise<void> {
  const configDir = `${projectDir}/.zed`;
  const configPath = `${configDir}/settings.json`;
  
  if (!existsSync(configDir)) {
    await mkdir(configDir, { recursive: true });
  }
  
  if (existsSync(configPath)) {
    console.log(chalk.yellow('‚ö† .zed/settings.json already exists, skipping'));
    return;
  }
  
  await writeFile(configPath, JSON.stringify(zedSettingsContent, null, 2));
}

/**
 * Generate git hooks configuration
 * @param projectDir - The project directory path
 */
export async function generateGitHooks(projectDir: string): Promise<void> {
  const hooksDir = `${projectDir}/.githooks`;
  const preCommitPath = `${hooksDir}/pre-commit`;
  
  if (!existsSync(hooksDir)) {
    await mkdir(hooksDir, { recursive: true });
  }
  
  const preCommitContent = `#!/bin/bash
# SpecSafe pre-commit hook

echo "üîç Running SpecSafe pre-commit checks..."

# Validate PROJECT_STATE.md exists
if [ ! -f "PROJECT_STATE.md" ]; then
  echo "‚ùå PROJECT_STATE.md not found. Run 'specsafe init' first."
  exit 1
fi

# Run spec validation (if we add a validate command)
# specsafe validate --silent || exit 1

echo "‚úÖ Pre-commit checks passed"
`;
  
  if (existsSync(preCommitPath)) {
    console.log(chalk.yellow('‚ö† .githooks/pre-commit already exists, skipping'));
    return;
  }
  
  await writeFile(preCommitPath, preCommitContent);
  
  // Make the hook executable (this won't work on Windows without special handling)
  try {
    const { exec } = await import('child_process');
    exec(`chmod +x ${preCommitPath}`);
  } catch {
    // Ignore chmod errors on Windows
  }
}
